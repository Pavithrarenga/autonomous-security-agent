
from bedrock_agentcore import BedrockAgentCoreApp
from agents.scanner import scanner_main
from agents.risk_assessor import risk_assessor_main
from agents.solution import solution_main
import urllib.request
import zipfile
import tempfile
import shutil
import os
import boto3
from github import Github
from datetime import datetime
import git

app = BedrockAgentCoreApp()

os.environ['GITHUB_TOKEN'] = 'YOUR-GITHUB-TOKEN'  # Replace with your actual GitHub token

def collect_all_s3_files(repo_name, s3_client):
    """Collect all S3 files from all agents for this repo"""
    s3_files = []
    buckets = ['security-agent-results', 'fixed-repo']
    
    for bucket in buckets:
        try:
            response = s3_client.list_objects_v2(Bucket=bucket, Prefix=repo_name)
            for obj in response.get('Contents', []):
                s3_files.append(f"s3://{bucket}/{obj['Key']}")
        except:
            pass
    return s3_files

def get_modified_files(original_dir, fixed_dir):
    """Compare directories to find modified files"""
    import filecmp
    modified = []
    
    for root, dirs, files in os.walk(fixed_dir):
        for file in files:
            if file.endswith(('.py', '.js', '.java', '.go', '.json', '.yaml', '.yml')):
                fixed_path = os.path.join(root, file)
                rel_path = os.path.relpath(fixed_path, fixed_dir)
                original_path = os.path.join(original_dir, rel_path)
                
                if not os.path.exists(original_path) or not filecmp.cmp(fixed_path, original_path, shallow=False):
                    modified.append(rel_path)
    return modified

def create_github_issue(repo_url, s3_files, modified_files, scan_results, risk_assessment, solution_results):
    """Create GitHub issue with scan results and S3 file info"""
    try:
        github_token = os.environ.get('GITHUB_TOKEN')
        if not github_token:
            print("No GITHUB_TOKEN found, skipping issue creation")
            return None
            
        g = Github(github_token)
        repo_name = repo_url.replace('https://github.com/', '').replace('.git', '')
        repo = g.get_repo(repo_name)
        
        # Create issue body
        issue_body = f"""## Security Scan Results

**Repository:** {repo_url}
**Scan Date:** {datetime.now().isoformat()}

### Modified Files ({len(modified_files)} files)
{chr(10).join([f'- {f}' for f in modified_files]) if modified_files else '- No files modified'}

### All S3 Artifacts ({len(s3_files)} files)
{chr(10).join([f'- {f}' for f in s3_files])}

### Scan Summary
{scan_results}...


### Risk Assessment Report
{risk_assessment}...

### Fixed Solutions
{solution_results}...

---
*Generated by Autonomous Security Agent*"""
        
        issue = repo.create_issue(
            title=f"Security Scan Results - {datetime.now().strftime('%Y-%m-%d')}",
            body=issue_body,
            labels=['security', 'automated-security-agent']
        )
        
        
        print(f"GitHub issue created: {issue.html_url}")
        return issue.html_url
        
    except Exception as e:
        print(f"Failed to create GitHub issue: {e}")
        return None
    
def create_github_pr(repo_url, branch_name, base_branch="main", title=None, body=None):
    """Create a GitHub Pull Request using PyGithub"""
    github_token = os.environ.get("GITHUB_TOKEN")
    if not github_token:
        print("‚ùå No GITHUB_TOKEN set. Skipping PR creation.")
        return None

    g = Github(github_token)
    repo_name = repo_url.replace("https://github.com/", "").replace(".git", "")
    repo = g.get_repo(repo_name)

    if not title:
        title = f"Automated Security Fixes ({branch_name})"
    if not body:
        body = "This pull request was automatically generated by the Autonomous Security Agent."

    try:
        pr = repo.create_pull(
            title=title,
            body=body,
            head=branch_name,  # source branch (pushed)
            base=base_branch   # usually main
        )
        print(f"‚úÖ Pull Request created: {pr.html_url}")
        return pr.html_url
    except Exception as e:
        print(f"‚ùå Failed to create PR: {e}")
        return None

@app.entrypoint
def app_entrypoint(payload):
    """Process a GitHub repository for vulnerabilities"""
    
    temp_dir = None
    
    try:
        # Extract URL from whatever format it comes in
        if isinstance(payload, dict):
            repo_url = payload.get('prompt') or payload.get('url') or payload.get('repo_url')
        else:
            repo_url = payload
        
        repo_url = str(repo_url).strip()
        print(f"Processing: {repo_url}")
        
        # Build download URL
        zip_url = repo_url.replace('.git', '').rstrip('/') + '/archive/refs/heads/main.zip'
        
        # Setup temp directory
        temp_dir = tempfile.mkdtemp(dir='/tmp')
        zip_path = os.path.join(temp_dir, 'repo.zip')
        
        # Download
        print("Downloading...")
        urllib.request.urlretrieve(zip_url, zip_path)
        print(f"Downloaded: {os.path.getsize(zip_path)} bytes")
        
        # Extract
        print("Extracting...")
        with zipfile.ZipFile(zip_path, 'r') as z:
            z.extractall(temp_dir)
        
        # Find repo directory
        dirs = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
        repo_dir = os.path.join(temp_dir, dirs[0])
        print(f"Repo at: {repo_dir}")
        
        # Create backup of original repo for comparison
        original_dir = os.path.join(temp_dir, 'original')
        shutil.copytree(repo_dir, original_dir)
        
        # Run analysis
        print("Scanning...")
        vuln_report = scanner_main(repo_dir)
        
        print("Assessing risks...")
        risk_assessment = risk_assessor_main(vuln_report, repo_dir)
        
        print("Generating solutions...")
        result = solution_main(risk_assessment, repo_dir)
        if str(result)=="Code Interpreter validation failed. Aborting solution agent.":
            return {"status": "Code Interpreter validation failed. Aborting solution agent."}
        else: 
            print("Preparing fixed repository results to upload to S3...")
            print("Compressing repo directory...")
            repo_name = repo_url.rstrip('/').split('/')[-1].replace('.git', '')
            print(f"Repo name: {repo_name}")
            s3_client = boto3.client('s3')
            s3_bucket_name = "fixed-repo"
            s3_arn = f"arn:aws:s3:::{s3_bucket_name}"
            compressed_zip_path = os.path.join(temp_dir, f'{repo_name}_compressed.zip')
            shutil.make_archive(base_name=compressed_zip_path.replace('.zip', ''), format='zip', root_dir=repo_dir)
            # Upload to S3
            s3_key = f"{repo_name}/repo_scanned.zip"
            
            print(f"Uploading to S3: s3://{s3_bucket_name}/{s3_key}")
            s3_client.upload_file(
                compressed_zip_path,
                s3_bucket_name,
                s3_key
            )
            print("Upload successful!")
            
            # Collect all S3 files and modified files
            all_s3_files = collect_all_s3_files(repo_name, s3_client)
            modified_files = get_modified_files(original_dir, repo_dir)
            issue_url = create_github_issue(repo_url, all_s3_files, modified_files, vuln_report, risk_assessment, result)
            # After issue creation
            branch_name = f"security-fix-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"

            # Clone the original repo (so it's a valid git repo)
            local_clone_path = os.path.join(temp_dir, "repo_clone")
            print(f"Cloning {repo_url} into {local_clone_path}...")
            repo_git = git.Repo.clone_from(
                repo_url.replace("https://", f"https://{os.environ['GITHUB_TOKEN']}@"),
                local_clone_path
            )

            # Create a new branch
            print(f"Creating branch {branch_name}...")
            new_branch = repo_git.create_head(branch_name)
            new_branch.checkout()

            # Copy modified files into clone
            print(f"Copying {len(modified_files)} modified files into cloned repo...")
            for rel_path in modified_files:
                src_file = os.path.join(repo_dir, rel_path)
                dest_file = os.path.join(local_clone_path, rel_path)
                os.makedirs(os.path.dirname(dest_file), exist_ok=True)
                shutil.copy2(src_file, dest_file)

            # Commit and push changes
            repo_git.git.add(A=True)
            repo_git.index.commit(f"Automated security fixes ({datetime.utcnow().isoformat()})")
            origin = repo_git.remote(name='origin')
            print("Pushing branch to remote...")
            origin.push(branch_name)

            # Create Pull Request
            pr_title = f"üîí Automated Security Fixes ‚Äî {datetime.utcnow().strftime('%Y-%m-%d')}"
            pr_body = (
                f"This PR contains automatically generated security fixes.\n\n"
                f"**Modified Files:**\n" +
                "\n".join([f"- {f}" for f in modified_files]) +
                "\n\n---\n*Generated by Autonomous Security Agent*"
            )

            pr_url = create_github_pr(repo_url, branch_name, base_branch="main", title=pr_title, body=pr_body)

            
            print("Done!")
            return {"status": "success", "github_issue": issue_url, "github_pr": pr_url, "solution_results": str(result)}
        
    except Exception as e:
        print(f"Error: {e}")
        raise
    finally:
        if temp_dir:
            shutil.rmtree(temp_dir, ignore_errors=True)

if __name__ == "__main__":
    app.run()