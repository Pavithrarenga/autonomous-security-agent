from strands import Agent
import boto3
from strands.models import BedrockModel
from strands_tools.tavily import tavily_extract
from strands_tools import file_read
import os
import re
from pathlib import Path
import sys
from datetime import datetime

os.environ["BUCKET_NAME"] = "security-agent-results"

def upload_agent_results(session, bucket_name, agent_type, repo_name, results):
    """Upload agent results to S3 with structured key."""
    try:
        s3_client = session.client('s3')
        
        # Create a structured S3 key
        date_str = datetime.utcnow().strftime('%Y/%m/%d')
        timestamp = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        s3_key = f"{agent_type}_results/{date_str}/{repo_name}_{timestamp}.md"
        document=f"""# {agent_type.title()} Agent Results
                **Date:** {datetime.utcnow().isoformat()} UTC
                **Repository**: {repo_name}
                **Agent:** {agent_type.title()} Agent
                ## Results
                {results}
                
                --- End of Report ---
                *Generated by Autonomous Security Agent (ASA)*
                """
                
        
        # Upload the results
        s3_client.put_object(
            Bucket=bucket_name,
            Key=s3_key,
            Body=document.encode('utf-8'),
            ContentType='text/markdown'
        )
        
        s3_url = f"s3://{bucket_name}/{s3_key}"
        print(f"{agent_type.title()} agent results uploaded to {s3_url}")
        return s3_url
    except Exception as e:
        print(f"Error uploading {agent_type} agent results to s3: {e}")
        return f"s3 upload failed: {str(e)}"   

def get_risk_assessor_system_prompt(repo_context):
    return f"""
You are a cybersecurity risk assessor.

When provided with a CVE number:
1. Extract the CVE number from the message
2. Use tavily_extract to get details from https://nvd.nist.gov/vuln/detail/{{CVE_NUMBER}}
3. Extract: CVSS version 3.x NIST: NVD score/severity, vector, description, affected products, references
4. Using the following application context, answer these questions: (i) What is the risk posed to the application? (ii) How can we prevent it from being exploited while working on a fix? (iii) What can be a proposed solution to this issue?

APPLICATION CONTEXT:
{repo_context}

5. Present in this format:

CVE: {{CVE_NUMBER}}
Severity: {{severity}} ({{score}})
Vector: {{cvss_vector}}
Description: {{description}}
Affected Products: {{products}}
References: {{references}}
Risk Posed: {{risk_to_application}}
Preventing Exploitation: {{exploit_prevention}}
Proposed Solution: {{proposed_solution}}
"""

def read_repository_context(repo_path, max_files=20):
    """Read key files from repository to provide application context."""
    repo_path = Path(repo_path)
    if not repo_path.exists():
        return f"Repository path {repo_path} does not exist."
    
    context_parts = []
    file_extensions = {'.py', '.js', '.ts', '.java', '.go', '.rs', '.cpp', '.c', '.h', '.yml', '.yaml', '.json', '.md', '.txt', '.cfg', '.conf'}
    
    files_read = 0
    for file_path in repo_path.rglob('*'):
        if files_read >= max_files:
            break
        if file_path.is_file() and file_path.suffix.lower() in file_extensions:
            if any(skip in str(file_path) for skip in ['.git', '__pycache__', 'node_modules', '.venv', 'venv']):
                continue
            try:
                content = file_path.read_text(encoding='utf-8', errors='ignore')[:2000]  # Limit content size
                context_parts.append(f"File: {file_path.relative_to(repo_path)}\n{content}\n{'='*50}")
                files_read += 1
            except Exception:
                continue
    
    return "\n\n".join(context_parts) if context_parts else "No readable files found in repository."

def get_risk_assessor_agent(session, repo_context):
    """Create and return a Risk Assessor agent instance."""
    bedrock_model = BedrockModel(
        model_id="anthropic.claude-3-5-sonnet-20241022-v2:0",
        temperature=0.2,
        top_p=0.8,
        boto_session=session,
    )

    return Agent(
        model=bedrock_model,
        system_prompt=get_risk_assessor_system_prompt(repo_context),
        tools=[tavily_extract, file_read],
    )

def extract_cve_numbers(report):
    """Extract all CVE numbers from a vulnerability report."""
    cve_pattern = r'CVE-\d{4}-\d{4,7}'
    return list(set(re.findall(cve_pattern, report, re.IGNORECASE)))

def assess_cve(cve_number, session, repo_context):
    """Assess a specific CVE and generate risk report."""
    agent = get_risk_assessor_agent(session, repo_context)
    return agent(f"Extract details for CVE: {cve_number}")

def assess_vulnerability_report(report, session, repo_context):
    """Extract all CVE numbers from report and assess each one."""
    cve_numbers = extract_cve_numbers(report)
    if not cve_numbers:
        return "No CVE numbers found in the report."
    
    results = []
    for cve in cve_numbers:
        try:
            assessment = assess_cve(cve, session, repo_context)
            results.append(str(assessment))
        except Exception as e:
            results.append(f"Error assessing {cve}: {str(e)}")
    
    return "\n\n" + "="*50 + "\n\n".join(results)

    
def risk_assessor_main(vuln_report, repo_to_assess):
    session = boto3.Session(region_name='ap-southeast-2')
    
    # Read repository context once
    repo_context = read_repository_context(repo_to_assess)
    
    assessment = assess_vulnerability_report(vuln_report, session, repo_context)
    # Upload results to S3
    bucket_name = 'security-agent-results'
    repo_name = os.path.basename(repo_to_assess)
    upload_result = upload_agent_results(session, bucket_name, "risk_assessor", repo_name, str(assessment))
    print(f"s3 upload result: {upload_result}")
    return str(assessment)

