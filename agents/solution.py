from strands import Agent, tool
from strands_tools import file_read, mem0_memory, use_llm
import boto3
from strands.models import BedrockModel
import os
from datetime import datetime
from .code_interpreter import code_interpreter_main


os.environ["BUCKET_NAME"] = "security-agent-results"

def upload_agent_results(session, bucket_name, agent_type, repo_name, results):
    """Upload agent results to S3 with structured key."""
    try:
        s3_client = session.client('s3')
        
        # Create a structured S3 key
        date_str = datetime.utcnow().strftime('%Y/%m/%d')
        timestamp = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        s3_key = f"{agent_type}_results/{date_str}/{repo_name}_{timestamp}.md"
        document=f"""# {agent_type.title()} Agent Results
                **Date:** {datetime.utcnow().isoformat()} UTC
                **Repository**: {repo_name}
                **Agent:** {agent_type.title()} Agent
                ## Results
                {results}
                
                --- End of Report ---
                *Generated by Autonomous Security Agent (ASA)*
                """   
        
        # Upload the results
        s3_client.put_object(
            Bucket=bucket_name,
            Key=s3_key,
            Body=document.encode('utf-8'),
            ContentType='text/markdown'
        )
        
        s3_url = f"s3://{bucket_name}/{s3_key}"
        print(f"{agent_type.title()} agent results uploaded to {s3_url}")
        return s3_url
    except Exception as e:
        print(f"Error uploading {agent_type} agent results to s3: {e}")
        return f"s3 upload failed: {str(e)}"   

@tool
def autonomous_file_write(content, file_path, user_id):
    """Write content to a file without user approval."""
    try:
        print(f"Writing to file: {file_path}")
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        return f"File {file_path} written successfully."
    except Exception as e:
        return f"Error writing to file {file_path}: {str(e)}"


def get_solution_system_prompt(risk_assessment_content, repo_to_assess):
    return f"""
You are a vulnerability fix implementation expert with conversational memory. Your capabilities include:
1. Reading all the files within the target application at {repo_to_assess}
2. Read proposed vulnerability fixes outlined below:

{risk_assessment_content}

3. Accurately identify which file in the target application needs to be modified with the proposed vulnerability fix.
4. Show the user regarding the proposed fix, providing a before vs after comparison.
5. Go and implement the fix in the corresponding file in the {repo_to_assess}.
6. Ensure that the fix is implemented successfully and saved properly in the S3 bucket 
"""

def solution_agent(session, risk_assessment_content, repo_to_assess, user_id):
    bedrock_model = BedrockModel(
        model_id="anthropic.claude-3-5-sonnet-20241022-v2:0",
        temperature=0.3,
        top_p=0.8,
        boto_session=session,
    )

    return Agent(
        model=bedrock_model,
        system_prompt=get_solution_system_prompt(risk_assessment_content, repo_to_assess),
        tools=[file_read, autonomous_file_write, mem0_memory, use_llm],
    )

def initialize_session_memory(agent, user_id, repo_to_assess, risk_assessment_content):
    """Initialize memory with session context"""
    init_context = f"Starting vulnerability fix session for repository: {repo_to_assess}. Risk assessment content: {risk_assessment_content}. User preferences: awaits approval before implementing fixes."
    agent.tool.mem0_memory(
        action="store",
        content=init_context,
        user_id=user_id
    )
    
def upload_files_to_agentcore_sandbox(files_data: list, aws_region: str) -> bool:
    """Upload files to AgentCore sandbox using writeFiles tool"""
    try:
        print(f"üîß Uploading {len(files_data)} files to AgentCore sandbox...")
        
        with code_session(aws_region) as code_client:
            response = code_client.invoke("writeFiles", {"content": files_data})
            
            for event in response["stream"]:
                result = event.get("result", {})
                if result.get("isError", False):
                    error_content = result.get("content", [{}])
                    error_text = error_content[0].get("text", "Unknown error") if error_content else "Unknown error"
                    print(f"‚ùå File upload error: {error_text}")
                    return False
                else:
                    content = result.get("content", [])
                    for item in content:
                        if item.get("type") == "text":
                            print(f"‚úÖ File upload result: {item.get('text', '')}")
                    return True
        
        return False
        
    except Exception as e:
        print(f"‚ùå File upload failed: {str(e)}")
        return False
  
# Code to execute
code_to_execute = """
print("Hello World!!!")
"""

def solution_main(risk_assessment_content, repo_to_assess):
    session = boto3.Session(region_name='ap-southeast-2')
    user_id = os.getenv('USER_ID', 'security_analyst')
    
    # Invoke custom code_interpreter agent to validate fixes before starting solution agent
    print("Invoking Code Interpreter to validate proposed fixes...")
    response_code_interpreter_result = code_interpreter_main(repo_to_assess, risk_assessment_content)
    print("Code Interpreter execution completed.")
    
    if response_code_interpreter_result.get("status") != "completed":
        print("Code Interpreter failed to validate proposed fixes. Aborting solution agent.")
        return "Code Interpreter validation failed. Aborting solution agent."
    
    else:
        print("Code Interpreter validated proposed fixes successfully. Proceeding with Solution Agent.")
        if response_code_interpreter_result.get("recommendation") == "APPROVE":
            print("Safe to approve changes. Starting Solution Agent...")
            # Create agent with context and memory
            agent = solution_agent(session, risk_assessment_content, repo_to_assess, user_id)
            
            # Initialize session memory
            initialize_session_memory(agent, user_id, repo_to_assess, risk_assessment_content)
            
            print("Solution Agent initialized with conversational memory.")
            print(f"Repository to assess: {repo_to_assess}")
            print(f"Risk assessment: {risk_assessment_content}")
            print(f"User ID: {user_id}")
            print("\n" + "="*50)
            
            # Start conversational fix process
            initial_prompt = "Please analyze the vulnerability fixes needed, and describe only the first fix you can suggest with a before/after comparison. Then, implement the fix in the corresponding file in the code."
            
            response = agent(initial_prompt, user_id=user_id)
            print(response)
            # Upload results to S3
            bucket_name = 'security-agent-results'
            repo_name = os.path.basename(repo_to_assess)
            upload_result = upload_agent_results(session, bucket_name, "solution", repo_name, str(response))
            print(f"s3 upload result: {upload_result}")
            return str(response)